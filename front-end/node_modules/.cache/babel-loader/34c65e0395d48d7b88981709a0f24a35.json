{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDomainLocale = getDomainLocale;\nexports.addLocale = addLocale;\nexports.delLocale = delLocale;\nexports.hasBasePath = hasBasePath;\nexports.addBasePath = addBasePath;\nexports.delBasePath = delBasePath;\nexports.isLocalURL = isLocalURL;\nexports.interpolateAs = interpolateAs;\nexports.resolveHref = resolveHref;\nexports.default = void 0;\n\nvar _normalizeTrailingSlash = require(\"../../../client/normalize-trailing-slash\");\n\nvar _routeLoader = require(\"../../../client/route-loader\");\n\nvar _isError = _interopRequireWildcard(require(\"../../../lib/is-error\"));\n\nvar _denormalizePagePath = require(\"../../../server/denormalize-page-path\");\n\nvar _normalizeLocalePath = require(\"../i18n/normalize-locale-path\");\n\nvar _mitt = _interopRequireDefault(require(\"../mitt\"));\n\nvar _utils = require(\"../utils\");\n\nvar _isDynamic = require(\"./utils/is-dynamic\");\n\nvar _parseRelativeUrl = require(\"./utils/parse-relative-url\");\n\nvar _querystring = require(\"./utils/querystring\");\n\nvar _resolveRewrites = _interopRequireDefault(require(\"./utils/resolve-rewrites\"));\n\nvar _routeMatcher = require(\"./utils/route-matcher\");\n\nvar _routeRegex = require(\"./utils/route-regex\");\n\nvar _getMiddlewareRegex = require(\"./utils/get-middleware-regex\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nlet detectDomainLocale;\n\nif (process.env.__NEXT_I18N_SUPPORT) {\n  detectDomainLocale = require('../i18n/detect-domain-locale').detectDomainLocale;\n}\n\nconst basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\n\nfunction buildCancellationError() {\n  return Object.assign(new Error('Route Cancelled'), {\n    cancelled: true\n  });\n}\n\nfunction addPathPrefix(path, prefix) {\n  if (!path.startsWith('/') || !prefix) {\n    return path;\n  }\n\n  const pathname = pathNoQueryHash(path);\n  return (0, _normalizeTrailingSlash).normalizePathTrailingSlash(`${prefix}${pathname}`) + path.substr(pathname.length);\n}\n\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n  if (process.env.__NEXT_I18N_SUPPORT) {\n    locale = locale || (0, _normalizeLocalePath).normalizeLocalePath(path, locales).detectedLocale;\n    const detectedDomain = detectDomainLocale(domainLocales, undefined, locale);\n\n    if (detectedDomain) {\n      return `http${detectedDomain.http ? '' : 's'}://${detectedDomain.domain}${basePath || ''}${locale === detectedDomain.defaultLocale ? '' : `/${locale}`}${path}`;\n    }\n\n    return false;\n  } else {\n    return false;\n  }\n}\n\nfunction addLocale(path, locale, defaultLocale) {\n  if (process.env.__NEXT_I18N_SUPPORT) {\n    const pathname = pathNoQueryHash(path);\n    const pathLower = pathname.toLowerCase();\n    const localeLower = locale && locale.toLowerCase();\n    return locale && locale !== defaultLocale && !pathLower.startsWith('/' + localeLower + '/') && pathLower !== '/' + localeLower ? addPathPrefix(path, '/' + locale) : path;\n  }\n\n  return path;\n}\n\nfunction delLocale(path, locale) {\n  if (process.env.__NEXT_I18N_SUPPORT) {\n    const pathname = pathNoQueryHash(path);\n    const pathLower = pathname.toLowerCase();\n    const localeLower = locale && locale.toLowerCase();\n    return locale && (pathLower.startsWith('/' + localeLower + '/') || pathLower === '/' + localeLower) ? (pathname.length === locale.length + 1 ? '/' : '') + path.substr(locale.length + 1) : path;\n  }\n\n  return path;\n}\n\nfunction pathNoQueryHash(path) {\n  const queryIndex = path.indexOf('?');\n  const hashIndex = path.indexOf('#');\n\n  if (queryIndex > -1 || hashIndex > -1) {\n    path = path.substring(0, queryIndex > -1 ? queryIndex : hashIndex);\n  }\n\n  return path;\n}\n\nfunction hasBasePath(path) {\n  path = pathNoQueryHash(path);\n  return path === basePath || path.startsWith(basePath + '/');\n}\n\nfunction addBasePath(path) {\n  // we only add the basepath on relative urls\n  return addPathPrefix(path, basePath);\n}\n\nfunction delBasePath(path) {\n  path = path.slice(basePath.length);\n  if (!path.startsWith('/')) path = `/${path}`;\n  return path;\n}\n\nfunction isLocalURL(url) {\n  // prevent a hydration mismatch on href for url with anchor refs\n  if (url.startsWith('/') || url.startsWith('#') || url.startsWith('?')) return true;\n\n  try {\n    // absolute urls can be local if they are on the same origin\n    const locationOrigin = (0, _utils).getLocationOrigin();\n    const resolved = new URL(url, locationOrigin);\n    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);\n  } catch (_) {\n    return false;\n  }\n}\n\nfunction interpolateAs(route, asPathname, query) {\n  let interpolatedRoute = '';\n  const dynamicRegex = (0, _routeRegex).getRouteRegex(route);\n  const dynamicGroups = dynamicRegex.groups;\n  const dynamicMatches = // Try to match the dynamic route against the asPath\n  (asPathname !== route ? (0, _routeMatcher).getRouteMatcher(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href\n  // TODO: should this take priority; also need to change in the router.\n  query;\n  interpolatedRoute = route;\n  const params = Object.keys(dynamicGroups);\n\n  if (!params.every(param => {\n    let value = dynamicMatches[param] || '';\n    const {\n      repeat,\n      optional\n    } = dynamicGroups[param]; // support single-level catch-all\n    // TODO: more robust handling for user-error (passing `/`)\n\n    let replaced = `[${repeat ? '...' : ''}${param}]`;\n\n    if (optional) {\n      replaced = `${!value ? '/' : ''}[${replaced}]`;\n    }\n\n    if (repeat && !Array.isArray(value)) value = [value];\n    return (optional || param in dynamicMatches) && ( // Interpolate group into data URL if present\n    interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map( // these values should be fully encoded instead of just\n    // path delimiter escaped since they are being inserted\n    // into the URL and we expect URL encoded segments\n    // when parsing dynamic route params\n    segment => encodeURIComponent(segment)).join('/') : encodeURIComponent(value)) || '/');\n  })) {\n    interpolatedRoute = '' // did not satisfy all requirements\n    ; // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n  }\n\n  return {\n    params,\n    result: interpolatedRoute\n  };\n}\n\nfunction omitParmsFromQuery(query, params) {\n  const filteredQuery = {};\n  Object.keys(query).forEach(key => {\n    if (!params.includes(key)) {\n      filteredQuery[key] = query[key];\n    }\n  });\n  return filteredQuery;\n}\n\nfunction resolveHref(router, href, resolveAs) {\n  // we use a dummy base url for relative urls\n  let base;\n  let urlAsString = typeof href === 'string' ? href : (0, _utils).formatWithValidation(href); // repeated slashes and backslashes in the URL are considered\n  // invalid and will never match a Next.js page/file\n\n  const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n  const urlAsStringNoProto = urlProtoMatch ? urlAsString.substr(urlProtoMatch[0].length) : urlAsString;\n  const urlParts = urlAsStringNoProto.split('?');\n\n  if ((urlParts[0] || '').match(/(\\/\\/|\\\\)/)) {\n    console.error(`Invalid href passed to next/router: ${urlAsString}, repeated forward-slashes (//) or backslashes \\\\ are not valid in the href`);\n    const normalizedUrl = (0, _utils).normalizeRepeatedSlashes(urlAsStringNoProto);\n    urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl;\n  } // Return because it cannot be routed by the Next.js router\n\n\n  if (!isLocalURL(urlAsString)) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n\n  try {\n    base = new URL(urlAsString.startsWith('#') ? router.asPath : router.pathname, 'http://n');\n  } catch (_) {\n    // fallback to / for invalid asPath values e.g. //\n    base = new URL('/', 'http://n');\n  }\n\n  try {\n    const finalUrl = new URL(urlAsString, base);\n    finalUrl.pathname = (0, _normalizeTrailingSlash).normalizePathTrailingSlash(finalUrl.pathname);\n    let interpolatedAs = '';\n\n    if ((0, _isDynamic).isDynamicRoute(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n      const query = (0, _querystring).searchParamsToUrlQuery(finalUrl.searchParams);\n      const {\n        result,\n        params\n      } = interpolateAs(finalUrl.pathname, finalUrl.pathname, query);\n\n      if (result) {\n        interpolatedAs = (0, _utils).formatWithValidation({\n          pathname: result,\n          hash: finalUrl.hash,\n          query: omitParmsFromQuery(query, params)\n        });\n      }\n    } // if the origin didn't change, it means we received a relative href\n\n\n    const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;\n  } catch (_1) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n}\n\nfunction stripOrigin(url) {\n  const origin = (0, _utils).getLocationOrigin();\n  return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\n\nfunction prepareUrlAs(router, url, as) {\n  // If url and as provided as an object representation,\n  // we'll format them into the string version here.\n  let [resolvedHref, resolvedAs] = resolveHref(router, url, true);\n  const origin = (0, _utils).getLocationOrigin();\n  const hrefHadOrigin = resolvedHref.startsWith(origin);\n  const asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);\n  resolvedHref = stripOrigin(resolvedHref);\n  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n  const preparedUrl = hrefHadOrigin ? resolvedHref : addBasePath(resolvedHref);\n  const preparedAs = as ? stripOrigin(resolveHref(router, as)) : resolvedAs || resolvedHref;\n  return {\n    url: preparedUrl,\n    as: asHadOrigin ? preparedAs : addBasePath(preparedAs)\n  };\n}\n\nfunction resolveDynamicRoute(pathname, pages) {\n  const cleanPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _denormalizePagePath).denormalizePagePath(pathname));\n\n  if (cleanPathname === '/404' || cleanPathname === '/_error') {\n    return pathname;\n  } // handle resolving href for dynamic routes\n\n\n  if (!pages.includes(cleanPathname)) {\n    // eslint-disable-next-line array-callback-return\n    pages.some(page => {\n      if ((0, _isDynamic).isDynamicRoute(page) && (0, _routeRegex).getRouteRegex(page).re.test(cleanPathname)) {\n        pathname = page;\n        return true;\n      }\n    });\n  }\n\n  return (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n}\n\nconst manualScrollRestoration = process.env.__NEXT_SCROLL_RESTORATION && typeof window !== 'undefined' && 'scrollRestoration' in window.history && !!function () {\n  try {\n    let v = '__next'; // eslint-disable-next-line no-sequences\n\n    return sessionStorage.setItem(v, v), sessionStorage.removeItem(v), true;\n  } catch (n) {}\n}();\nconst SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\n\nfunction fetchRetry(url, attempts, opts) {\n  return fetch(url, {\n    // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n    // Cookies may also be required for `getServerSideProps`.\n    //\n    // > `fetch` wonâ€™t send cookies, unless you set the credentials init\n    // > option.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n    //\n    // > For maximum browser compatibility when it comes to sending &\n    // > receiving cookies, always supply the `credentials: 'same-origin'`\n    // > option instead of relying on the default.\n    // https://github.com/github/fetch#caveats\n    credentials: 'same-origin'\n  }).then(res => {\n    if (!res.ok) {\n      if (attempts > 1 && res.status >= 500) {\n        return fetchRetry(url, attempts - 1, opts);\n      }\n\n      if (res.status === 404) {\n        return res.json().then(data => {\n          if (data.notFound) {\n            return {\n              notFound: SSG_DATA_NOT_FOUND\n            };\n          }\n\n          throw new Error(`Failed to load static props`);\n        });\n      }\n\n      throw new Error(`Failed to load static props`);\n    }\n\n    return opts.text ? res.text() : res.json();\n  });\n}\n\nfunction fetchNextData(dataHref, isServerRender, text, inflightCache, persistCache) {\n  const {\n    href: cacheKey\n  } = new URL(dataHref, window.location.href);\n\n  if (inflightCache[cacheKey] !== undefined) {\n    return inflightCache[cacheKey];\n  }\n\n  return inflightCache[cacheKey] = fetchRetry(dataHref, isServerRender ? 3 : 1, {\n    text\n  }).catch(err => {\n    // We should only trigger a server-side transition if this was caused\n    // on a client-side transition. Otherwise, we'd get into an infinite\n    // loop.\n    if (!isServerRender) {\n      (0, _routeLoader).markAssetError(err);\n    }\n\n    throw err;\n  }).then(data => {\n    if (!persistCache || process.env.NODE_ENV !== 'production') {\n      delete inflightCache[cacheKey];\n    }\n\n    return data;\n  }).catch(err => {\n    delete inflightCache[cacheKey];\n    throw err;\n  });\n}\n\nclass Router {\n  constructor(pathname, query, as, _ref) {\n    let {\n      initialProps,\n      pageLoader,\n      App,\n      wrapApp,\n      Component,\n      err,\n      subscription,\n      isFallback,\n      locale,\n      locales,\n      defaultLocale,\n      domainLocales,\n      isPreview\n    } = _ref;\n    // Static Data Cache\n    this.sdc = {}; // In-flight Server Data Requests, for deduping\n\n    this.sdr = {}; // In-flight middleware preflight requests\n\n    this.sde = {};\n    this._idx = 0;\n\n    this.onPopState = e => {\n      const state = e.state;\n\n      if (!state) {\n        // We get state as undefined for two reasons.\n        //  1. With older safari (< 8) and older chrome (< 34)\n        //  2. When the URL changed with #\n        //\n        // In the both cases, we don't need to proceed and change the route.\n        // (as it's already changed)\n        // But we can simply replace the state with the new changes.\n        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n        // So, doing the following for (1) does no harm.\n        const {\n          pathname,\n          query\n        } = this;\n        this.changeState('replaceState', (0, _utils).formatWithValidation({\n          pathname: addBasePath(pathname),\n          query\n        }), (0, _utils).getURL());\n        return;\n      }\n\n      if (!state.__N) {\n        return;\n      }\n\n      let forcedScroll;\n      const {\n        url,\n        as,\n        options,\n        idx\n      } = state;\n\n      if (process.env.__NEXT_SCROLL_RESTORATION) {\n        if (manualScrollRestoration) {\n          if (this._idx !== idx) {\n            // Snapshot current scroll position:\n            try {\n              sessionStorage.setItem('__next_scroll_' + this._idx, JSON.stringify({\n                x: self.pageXOffset,\n                y: self.pageYOffset\n              }));\n            } catch {} // Restore old scroll position:\n\n\n            try {\n              const v = sessionStorage.getItem('__next_scroll_' + idx);\n              forcedScroll = JSON.parse(v);\n            } catch {\n              forcedScroll = {\n                x: 0,\n                y: 0\n              };\n            }\n          }\n        }\n      }\n\n      this._idx = idx;\n      const {\n        pathname\n      } = (0, _parseRelativeUrl).parseRelativeUrl(url); // Make sure we don't re-render on initial load,\n      // can be caused by navigating back from an external site\n\n      if (this.isSsr && as === addBasePath(this.asPath) && pathname === addBasePath(this.pathname)) {\n        return;\n      } // If the downstream application returns falsy, return.\n      // They will then be responsible for handling the event.\n\n\n      if (this._bps && !this._bps(state)) {\n        return;\n      }\n\n      this.change('replaceState', url, as, Object.assign({}, options, {\n        shallow: options.shallow && this._shallow,\n        locale: options.locale || this.defaultLocale\n      }), forcedScroll);\n    }; // represents the current component key\n\n\n    const route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname); // set up the component cache (by route keys)\n\n    this.components = {}; // We should not keep the cache, if there's an error\n    // Otherwise, this cause issues when when going back and\n    // come again to the errored page.\n\n    if (pathname !== '/_error') {\n      var ref;\n      this.components[route] = {\n        Component,\n        initial: true,\n        props: initialProps,\n        err,\n        __N_SSG: initialProps && initialProps.__N_SSG,\n        __N_SSP: initialProps && initialProps.__N_SSP,\n        __N_RSC: !!((ref = Component) === null || ref === void 0 ? void 0 : ref.__next_rsc__)\n      };\n    }\n\n    this.components['/_app'] = {\n      Component: App,\n      styleSheets: []\n    }; // Backwards compat for Router.router.events\n    // TODO: Should be remove the following major version as it was never documented\n\n    this.events = Router.events;\n    this.pageLoader = pageLoader; // if auto prerendered and dynamic route wait to update asPath\n    // until after mount to prevent hydration mismatch\n\n    const autoExportDynamic = (0, _isDynamic).isDynamicRoute(pathname) && self.__NEXT_DATA__.autoExport;\n\n    this.basePath = basePath;\n    this.sub = subscription;\n    this.clc = null;\n    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating\n    // back from external site\n\n    this.isSsr = true;\n    this.isLocaleDomain = false;\n    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !process.env.__NEXT_HAS_REWRITES);\n\n    if (process.env.__NEXT_I18N_SUPPORT) {\n      this.locales = locales;\n      this.defaultLocale = defaultLocale;\n      this.domainLocales = domainLocales;\n      this.isLocaleDomain = !!detectDomainLocale(domainLocales, self.location.hostname);\n    }\n\n    this.state = {\n      route,\n      pathname,\n      query,\n      asPath: autoExportDynamic ? pathname : as,\n      isPreview: !!isPreview,\n      locale: process.env.__NEXT_I18N_SUPPORT ? locale : undefined,\n      isFallback\n    };\n\n    if (typeof window !== 'undefined') {\n      // make sure \"as\" doesn't start with double slashes or else it can\n      // throw an error as it's considered invalid\n      if (as.substr(0, 2) !== '//') {\n        // in order for `e.state` to work on the `onpopstate` event\n        // we have to register the initial route upon initialization\n        const options = {\n          locale\n        };\n        options._shouldResolveHref = as !== pathname;\n        this.changeState('replaceState', (0, _utils).formatWithValidation({\n          pathname: addBasePath(pathname),\n          query\n        }), (0, _utils).getURL(), options);\n      }\n\n      window.addEventListener('popstate', this.onPopState); // enable custom scroll restoration handling when available\n      // otherwise fallback to browser's default handling\n\n      if (process.env.__NEXT_SCROLL_RESTORATION) {\n        if (manualScrollRestoration) {\n          window.history.scrollRestoration = 'manual';\n        }\n      }\n    }\n  }\n\n  reload() {\n    window.location.reload();\n  }\n  /**\n  * Go back in history\n  */\n\n\n  back() {\n    window.history.back();\n  }\n  /**\n  * Performs a `pushState` with arguments\n  * @param url of the route\n  * @param as masks `url` for the browser\n  * @param options object you can define `shallow` and other options\n  */\n\n\n  push(url, as) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (process.env.__NEXT_SCROLL_RESTORATION) {\n      // TODO: remove in the future when we update history before route change\n      // is complete, as the popstate event should handle this capture.\n      if (manualScrollRestoration) {\n        try {\n          // Snapshot scroll position right before navigating to a new page:\n          sessionStorage.setItem('__next_scroll_' + this._idx, JSON.stringify({\n            x: self.pageXOffset,\n            y: self.pageYOffset\n          }));\n        } catch {}\n      }\n    }\n\n    ({\n      url,\n      as\n    } = prepareUrlAs(this, url, as));\n    return this.change('pushState', url, as, options);\n  }\n  /**\n  * Performs a `replaceState` with arguments\n  * @param url of the route\n  * @param as masks `url` for the browser\n  * @param options object you can define `shallow` and other options\n  */\n\n\n  replace(url, as) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    ({\n      url,\n      as\n    } = prepareUrlAs(this, url, as));\n    return this.change('replaceState', url, as, options);\n  }\n\n  async change(method, url, as, options, forcedScroll) {\n    if (!isLocalURL(url)) {\n      window.location.href = url;\n      return false;\n    }\n\n    const shouldResolveHref = options._h || options._shouldResolveHref || pathNoQueryHash(url) === pathNoQueryHash(as);\n    const nextState = { ...this.state\n    }; // for static pages with query params in the URL we delay\n    // marking the router ready until after the query is updated\n\n    if (options._h) {\n      this.isReady = true;\n    }\n\n    const prevLocale = nextState.locale;\n\n    if (process.env.__NEXT_I18N_SUPPORT) {\n      nextState.locale = options.locale === false ? this.defaultLocale : options.locale || nextState.locale;\n\n      if (typeof options.locale === 'undefined') {\n        options.locale = nextState.locale;\n      }\n\n      const parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(hasBasePath(as) ? delBasePath(as) : as);\n      const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, this.locales);\n\n      if (localePathResult.detectedLocale) {\n        nextState.locale = localePathResult.detectedLocale;\n        parsedAs.pathname = addBasePath(parsedAs.pathname);\n        as = (0, _utils).formatWithValidation(parsedAs);\n        url = addBasePath((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(url) ? delBasePath(url) : url, this.locales).pathname);\n      }\n\n      let didNavigate = false; // we need to wrap this in the env check again since regenerator runtime\n      // moves this on its own due to the return\n\n      if (process.env.__NEXT_I18N_SUPPORT) {\n        var ref; // if the locale isn't configured hard navigate to show 404 page\n\n        if (!((ref = this.locales) === null || ref === void 0 ? void 0 : ref.includes(nextState.locale))) {\n          parsedAs.pathname = addLocale(parsedAs.pathname, nextState.locale);\n          window.location.href = (0, _utils).formatWithValidation(parsedAs); // this was previously a return but was removed in favor\n          // of better dead code elimination with regenerator runtime\n\n          didNavigate = true;\n        }\n      }\n\n      const detectedDomain = detectDomainLocale(this.domainLocales, undefined, nextState.locale); // we need to wrap this in the env check again since regenerator runtime\n      // moves this on its own due to the return\n\n      if (process.env.__NEXT_I18N_SUPPORT) {\n        // if we are navigating to a domain locale ensure we redirect to the\n        // correct domain\n        if (!didNavigate && detectedDomain && this.isLocaleDomain && self.location.hostname !== detectedDomain.domain) {\n          const asNoBasePath = delBasePath(as);\n          window.location.href = `http${detectedDomain.http ? '' : 's'}://${detectedDomain.domain}${addBasePath(`${nextState.locale === detectedDomain.defaultLocale ? '' : `/${nextState.locale}`}${asNoBasePath === '/' ? '' : asNoBasePath}` || '/')}`; // this was previously a return but was removed in favor\n          // of better dead code elimination with regenerator runtime\n\n          didNavigate = true;\n        }\n      }\n\n      if (didNavigate) {\n        return new Promise(() => {});\n      }\n    }\n\n    if (!options._h) {\n      this.isSsr = false;\n    } // marking route changes as a navigation start entry\n\n\n    if (_utils.ST) {\n      performance.mark('routeChange');\n    }\n\n    const {\n      shallow = false,\n      scroll = true\n    } = options;\n    const routeProps = {\n      shallow\n    };\n\n    if (this._inFlightRoute) {\n      this.abortComponentLoad(this._inFlightRoute, routeProps);\n    }\n\n    as = addBasePath(addLocale(hasBasePath(as) ? delBasePath(as) : as, options.locale, this.defaultLocale));\n    const cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, nextState.locale);\n    this._inFlightRoute = as;\n    let localeChange = prevLocale !== nextState.locale; // If the url change is only related to a hash change\n    // We should not proceed. We should only change the state.\n    // WARNING: `_h` is an internal option for handing Next.js client-side\n    // hydration. Your app should _never_ use this property. It may change at\n    // any time without notice.\n\n    if (!options._h && this.onlyAHashChange(cleanedAs) && !localeChange) {\n      nextState.asPath = cleanedAs;\n      Router.events.emit('hashChangeStart', as, routeProps); // TODO: do we need the resolved href when only a hash change?\n\n      this.changeState(method, url, as, { ...options,\n        scroll: false\n      });\n\n      if (scroll) {\n        this.scrollToHash(cleanedAs);\n      }\n\n      this.set(nextState, this.components[nextState.route], null);\n      Router.events.emit('hashChangeComplete', as, routeProps);\n      return true;\n    }\n\n    let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n    let {\n      pathname,\n      query\n    } = parsed; // The build manifest needs to be loaded before auto-static dynamic pages\n    // get their query parameters to allow ensuring they can be parsed properly\n    // when rewritten to\n\n    let pages, rewrites;\n\n    try {\n      [pages, {\n        __rewrites: rewrites\n      }] = await Promise.all([this.pageLoader.getPageList(), (0, _routeLoader).getClientBuildManifest(), this.pageLoader.getMiddlewareList()]);\n    } catch (err) {\n      // If we fail to resolve the page list or client-build manifest, we must\n      // do a server-side transition:\n      window.location.href = as;\n      return false;\n    } // If asked to change the current URL we should reload the current page\n    // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n    // We also need to set the method = replaceState always\n    // as this should not go into the history (That's how browsers work)\n    // We should compare the new asPath to the current asPath, not the url\n\n\n    if (!this.urlIsNew(cleanedAs) && !localeChange) {\n      method = 'replaceState';\n    } // we need to resolve the as value using rewrites for dynamic SSG\n    // pages to allow building the data URL correctly\n\n\n    let resolvedAs = as; // url and as should always be prefixed with basePath by this\n    // point by either next/link or router.push/replace so strip the\n    // basePath from the pathname to match the pages dir 1-to-1\n\n    pathname = pathname ? (0, _normalizeTrailingSlash).removePathTrailingSlash(delBasePath(pathname)) : pathname;\n\n    if (shouldResolveHref && pathname !== '/_error') {\n      options._shouldResolveHref = true;\n\n      if (process.env.__NEXT_HAS_REWRITES && as.startsWith('/')) {\n        const rewritesResult = (0, _resolveRewrites).default(addBasePath(addLocale(cleanedAs, nextState.locale)), pages, rewrites, query, p => resolveDynamicRoute(p, pages), this.locales);\n\n        if (rewritesResult.externalDest) {\n          location.href = as;\n          return true;\n        }\n\n        resolvedAs = rewritesResult.asPath;\n\n        if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n          // if this directly matches a page we need to update the href to\n          // allow the correct page chunk to be loaded\n          pathname = rewritesResult.resolvedHref;\n          parsed.pathname = addBasePath(pathname);\n          url = (0, _utils).formatWithValidation(parsed);\n        }\n      } else {\n        parsed.pathname = resolveDynamicRoute(pathname, pages);\n\n        if (parsed.pathname !== pathname) {\n          pathname = parsed.pathname;\n          parsed.pathname = addBasePath(pathname);\n          url = (0, _utils).formatWithValidation(parsed);\n        }\n      }\n    }\n\n    if (!isLocalURL(as)) {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error(`Invalid href: \"${url}\" and as: \"${as}\", received relative href and external as` + `\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as`);\n      }\n\n      window.location.href = as;\n      return false;\n    }\n\n    resolvedAs = delLocale(delBasePath(resolvedAs), nextState.locale);\n    /**\n    * If the route update was triggered for client-side hydration and\n    * the rendered route is not dynamic do not check the preflight\n    * request as it is not necessary.\n    */\n\n    if (options._h !== 1 || (0, _isDynamic).isDynamicRoute((0, _normalizeTrailingSlash).removePathTrailingSlash(pathname))) {\n      const effect = await this._preflightRequest({\n        as,\n        cache: process.env.NODE_ENV === 'production',\n        pages,\n        pathname,\n        query,\n        locale: nextState.locale,\n        isPreview: nextState.isPreview\n      });\n\n      if (effect.type === 'rewrite') {\n        query = { ...query,\n          ...effect.parsedAs.query\n        };\n        resolvedAs = effect.asPath;\n        pathname = effect.resolvedHref;\n        parsed.pathname = effect.resolvedHref;\n        url = (0, _utils).formatWithValidation(parsed);\n      } else if (effect.type === 'redirect' && effect.newAs) {\n        return this.change(method, effect.newUrl, effect.newAs, options);\n      } else if (effect.type === 'redirect' && effect.destination) {\n        window.location.href = effect.destination;\n        return new Promise(() => {});\n      } else if (effect.type === 'refresh' && as !== window.location.pathname) {\n        window.location.href = as;\n        return new Promise(() => {});\n      }\n    }\n\n    const route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n\n    if ((0, _isDynamic).isDynamicRoute(route)) {\n      const parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs);\n      const asPathname = parsedAs.pathname;\n      const routeRegex = (0, _routeRegex).getRouteRegex(route);\n      const routeMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(asPathname);\n      const shouldInterpolate = route === asPathname;\n      const interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};\n\n      if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n        const missingParams = Object.keys(routeRegex.groups).filter(param => !query[param]);\n\n        if (missingParams.length > 0) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(`${shouldInterpolate ? `Interpolating href` : `Mismatching \\`as\\` and \\`href\\``} failed to manually provide ` + `the params: ${missingParams.join(', ')} in the \\`href\\`'s \\`query\\``);\n          }\n\n          throw new Error((shouldInterpolate ? `The provided \\`href\\` (${url}) value is missing query values (${missingParams.join(', ')}) to be interpolated properly. ` : `The provided \\`as\\` value (${asPathname}) is incompatible with the \\`href\\` value (${route}). `) + `Read more: https://nextjs.org/docs/messages/${shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'}`);\n        }\n      } else if (shouldInterpolate) {\n        as = (0, _utils).formatWithValidation(Object.assign({}, parsedAs, {\n          pathname: interpolatedAs.result,\n          query: omitParmsFromQuery(query, interpolatedAs.params)\n        }));\n      } else {\n        // Merge params into `query`, overwriting any specified in search\n        Object.assign(query, routeMatch);\n      }\n    }\n\n    Router.events.emit('routeChangeStart', as, routeProps);\n\n    try {\n      var ref, ref1;\n      let routeInfo = await this.getRouteInfo(route, pathname, query, as, resolvedAs, routeProps, nextState.locale, nextState.isPreview);\n      let {\n        error,\n        props,\n        __N_SSG,\n        __N_SSP\n      } = routeInfo; // handle redirect on client-transition\n\n      if ((__N_SSG || __N_SSP) && props) {\n        if (props.pageProps && props.pageProps.__N_REDIRECT) {\n          const destination = props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt\n          // client-navigation if it is falling back to hard navigation if\n          // it's not\n\n          if (destination.startsWith('/') && props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n            const parsedHref = (0, _parseRelativeUrl).parseRelativeUrl(destination);\n            parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n            const {\n              url: newUrl,\n              as: newAs\n            } = prepareUrlAs(this, destination, destination);\n            return this.change(method, newUrl, newAs, options);\n          }\n\n          window.location.href = destination;\n          return new Promise(() => {});\n        }\n\n        nextState.isPreview = !!props.__N_PREVIEW; // handle SSG data 404\n\n        if (props.notFound === SSG_DATA_NOT_FOUND) {\n          let notFoundRoute;\n\n          try {\n            await this.fetchComponent('/404');\n            notFoundRoute = '/404';\n          } catch (_) {\n            notFoundRoute = '/_error';\n          }\n\n          routeInfo = await this.getRouteInfo(notFoundRoute, notFoundRoute, query, as, resolvedAs, {\n            shallow: false\n          }, nextState.locale, nextState.isPreview);\n        }\n      }\n\n      Router.events.emit('beforeHistoryChange', as, routeProps);\n      this.changeState(method, url, as, options);\n\n      if (options._h && pathname === '/_error' && ((ref = self.__NEXT_DATA__.props) === null || ref === void 0 ? void 0 : (ref1 = ref.pageProps) === null || ref1 === void 0 ? void 0 : ref1.statusCode) === 500 && (props === null || props === void 0 ? void 0 : props.pageProps)) {\n        // ensure statusCode is still correct for static 500 page\n        // when updating query information\n        props.pageProps.statusCode = 500;\n      } // shallow routing is only allowed for same page URL changes.\n\n\n      const isValidShallowRoute = options.shallow && nextState.route === route;\n\n      var _scroll;\n\n      const shouldScroll = (_scroll = options.scroll) !== null && _scroll !== void 0 ? _scroll : !isValidShallowRoute;\n      const resetScroll = shouldScroll ? {\n        x: 0,\n        y: 0\n      } : null;\n      await this.set({ ...nextState,\n        route,\n        pathname,\n        query,\n        asPath: cleanedAs,\n        isFallback: false\n      }, routeInfo, forcedScroll !== null && forcedScroll !== void 0 ? forcedScroll : resetScroll).catch(e => {\n        if (e.cancelled) error = error || e;else throw e;\n      });\n\n      if (error) {\n        Router.events.emit('routeChangeError', error, cleanedAs, routeProps);\n        throw error;\n      }\n\n      if (process.env.__NEXT_I18N_SUPPORT) {\n        if (nextState.locale) {\n          document.documentElement.lang = nextState.locale;\n        }\n      }\n\n      Router.events.emit('routeChangeComplete', as, routeProps);\n      return true;\n    } catch (err1) {\n      if ((0, _isError).default(err1) && err1.cancelled) {\n        return false;\n      }\n\n      throw err1;\n    }\n  }\n\n  changeState(method, url, as) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof window.history === 'undefined') {\n        console.error(`Warning: window.history is not available.`);\n        return;\n      }\n\n      if (typeof window.history[method] === 'undefined') {\n        console.error(`Warning: window.history.${method} is not available`);\n        return;\n      }\n    }\n\n    if (method !== 'pushState' || (0, _utils).getURL() !== as) {\n      this._shallow = options.shallow;\n      window.history[method]({\n        url,\n        as,\n        options,\n        __N: true,\n        idx: this._idx = method !== 'pushState' ? this._idx : this._idx + 1\n      }, // Most browsers currently ignores this parameter, although they may use it in the future.\n      // Passing the empty string here should be safe against future changes to the method.\n      // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n      '', as);\n    }\n  }\n\n  async handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n    if (err.cancelled) {\n      // bubble up cancellation errors\n      throw err;\n    }\n\n    if ((0, _routeLoader).isAssetError(err) || loadErrorFail) {\n      Router.events.emit('routeChangeError', err, as, routeProps); // If we can't load the page it could be one of following reasons\n      //  1. Page doesn't exists\n      //  2. Page does exist in a different zone\n      //  3. Internal error while loading the page\n      // So, doing a hard reload is the proper way to deal with this.\n\n      window.location.href = as; // Changing the URL doesn't block executing the current code path.\n      // So let's throw a cancellation error stop the routing logic.\n\n      throw buildCancellationError();\n    }\n\n    try {\n      let Component;\n      let styleSheets;\n      let props;\n\n      if (typeof Component === 'undefined' || typeof styleSheets === 'undefined') {\n        ({\n          page: Component,\n          styleSheets\n        } = await this.fetchComponent('/_error'));\n      }\n\n      const routeInfo = {\n        props,\n        Component,\n        styleSheets,\n        err,\n        error: err\n      };\n\n      if (!routeInfo.props) {\n        try {\n          routeInfo.props = await this.getInitialProps(Component, {\n            err,\n            pathname,\n            query\n          });\n        } catch (gipErr) {\n          console.error('Error in error page `getInitialProps`: ', gipErr);\n          routeInfo.props = {};\n        }\n      }\n\n      return routeInfo;\n    } catch (routeInfoErr) {\n      return this.handleRouteInfoError((0, _isError).default(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + ''), pathname, query, as, routeProps, true);\n    }\n  }\n\n  async getRouteInfo(route, pathname, query, as, resolvedAs, routeProps, locale, isPreview) {\n    try {\n      const existingRouteInfo = this.components[route];\n\n      if (routeProps.shallow && existingRouteInfo && this.route === route) {\n        return existingRouteInfo;\n      }\n\n      let cachedRouteInfo = undefined; // can only use non-initial route info\n      // cannot reuse route info in development since it can change after HMR\n\n      if (process.env.NODE_ENV !== 'development' && existingRouteInfo && !('initial' in existingRouteInfo)) {\n        cachedRouteInfo = existingRouteInfo;\n      }\n\n      const routeInfo = cachedRouteInfo || (await this.fetchComponent(route).then(res => ({\n        Component: res.page,\n        styleSheets: res.styleSheets,\n        __N_SSG: res.mod.__N_SSG,\n        __N_SSP: res.mod.__N_SSP,\n        __N_RSC: !!res.page.__next_rsc__\n      })));\n      const {\n        Component,\n        __N_SSG,\n        __N_SSP,\n        __N_RSC\n      } = routeInfo;\n\n      if (process.env.NODE_ENV !== 'production') {\n        const {\n          isValidElementType\n        } = require('next/dist/compiled/react-is');\n\n        if (!isValidElementType(Component)) {\n          throw new Error(`The default export is not a React Component in page: \"${pathname}\"`);\n        }\n      }\n\n      let dataHref;\n\n      if (__N_SSG || __N_SSP || __N_RSC) {\n        dataHref = this.pageLoader.getDataHref({\n          href: (0, _utils).formatWithValidation({\n            pathname,\n            query\n          }),\n          asPath: resolvedAs,\n          ssg: __N_SSG,\n          rsc: __N_RSC,\n          locale\n        });\n      }\n\n      const props = await this._getData(() => __N_SSG || __N_SSP ? fetchNextData(dataHref, this.isSsr, false, __N_SSG ? this.sdc : this.sdr, !!__N_SSG && !isPreview) : this.getInitialProps(Component, // we provide AppTree later so this needs to be `any`\n      {\n        pathname,\n        query,\n        asPath: as,\n        locale,\n        locales: this.locales,\n        defaultLocale: this.defaultLocale\n      }));\n\n      if (__N_RSC) {\n        const {\n          fresh,\n          data\n        } = await this._getData(() => this._getFlightData(dataHref));\n        props.pageProps = Object.assign(props.pageProps, {\n          __flight_serialized__: data,\n          __flight_fresh__: fresh\n        });\n      }\n\n      routeInfo.props = props;\n      this.components[route] = routeInfo;\n      return routeInfo;\n    } catch (err) {\n      return this.handleRouteInfoError((0, _isError).getProperError(err), pathname, query, as, routeProps);\n    }\n  }\n\n  set(state, data, resetScroll) {\n    this.state = state;\n    return this.sub(data, this.components['/_app'].Component, resetScroll);\n  }\n  /**\n  * Callback to execute before replacing router state\n  * @param cb callback to be executed\n  */\n\n\n  beforePopState(cb) {\n    this._bps = cb;\n  }\n\n  onlyAHashChange(as) {\n    if (!this.asPath) return false;\n    const [oldUrlNoHash, oldHash] = this.asPath.split('#');\n    const [newUrlNoHash, newHash] = as.split('#'); // Makes sure we scroll to the provided hash if the url/hash are the same\n\n    if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n      return true;\n    } // If the urls are change, there's more than a hash change\n\n\n    if (oldUrlNoHash !== newUrlNoHash) {\n      return false;\n    } // If the hash has changed, then it's a hash only change.\n    // This check is necessary to handle both the enter and\n    // leave hash === '' cases. The identity case falls through\n    // and is treated as a next reload.\n\n\n    return oldHash !== newHash;\n  }\n\n  scrollToHash(as) {\n    const [, hash = ''] = as.split('#'); // Scroll to top if the hash is just `#` with no value or `#top`\n    // To mirror browsers\n\n    if (hash === '' || hash === 'top') {\n      window.scrollTo(0, 0);\n      return;\n    } // First we check if the element by id is found\n\n\n    const idEl = document.getElementById(hash);\n\n    if (idEl) {\n      idEl.scrollIntoView();\n      return;\n    } // If there's no element with the id, we check the `name` property\n    // To mirror browsers\n\n\n    const nameEl = document.getElementsByName(hash)[0];\n\n    if (nameEl) {\n      nameEl.scrollIntoView();\n    }\n  }\n\n  urlIsNew(asPath) {\n    return this.asPath !== asPath;\n  }\n  /**\n  * Prefetch page code, you may wait for the data during page rendering.\n  * This feature only works in production!\n  * @param url the href of prefetched page\n  * @param asPath the as path of the prefetched page\n  */\n\n\n  async prefetch(url) {\n    let asPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n    let {\n      pathname,\n      query\n    } = parsed;\n\n    if (process.env.__NEXT_I18N_SUPPORT) {\n      if (options.locale === false) {\n        pathname = (0, _normalizeLocalePath).normalizeLocalePath(pathname, this.locales).pathname;\n        parsed.pathname = pathname;\n        url = (0, _utils).formatWithValidation(parsed);\n        let parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(asPath);\n        const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, this.locales);\n        parsedAs.pathname = localePathResult.pathname;\n        options.locale = localePathResult.detectedLocale || this.defaultLocale;\n        asPath = (0, _utils).formatWithValidation(parsedAs);\n      }\n    }\n\n    const pages = await this.pageLoader.getPageList();\n    let resolvedAs = asPath;\n\n    if (process.env.__NEXT_HAS_REWRITES && asPath.startsWith('/')) {\n      let rewrites;\n      ({\n        __rewrites: rewrites\n      } = await (0, _routeLoader).getClientBuildManifest());\n      const rewritesResult = (0, _resolveRewrites).default(addBasePath(addLocale(asPath, this.locale)), pages, rewrites, parsed.query, p => resolveDynamicRoute(p, pages), this.locales);\n\n      if (rewritesResult.externalDest) {\n        return;\n      }\n\n      resolvedAs = delLocale(delBasePath(rewritesResult.asPath), this.locale);\n\n      if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n        // if this directly matches a page we need to update the href to\n        // allow the correct page chunk to be loaded\n        pathname = rewritesResult.resolvedHref;\n        parsed.pathname = pathname;\n        url = (0, _utils).formatWithValidation(parsed);\n      }\n    } else {\n      parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n\n      if (parsed.pathname !== pathname) {\n        pathname = parsed.pathname;\n        parsed.pathname = pathname;\n        url = (0, _utils).formatWithValidation(parsed);\n      }\n    } // Prefetch is not supported in development mode because it would trigger on-demand-entries\n\n\n    if (process.env.NODE_ENV !== 'production') {\n      return;\n    }\n\n    const effects = await this._preflightRequest({\n      as: addBasePath(asPath),\n      cache: true,\n      pages,\n      pathname,\n      query,\n      locale: this.locale,\n      isPreview: this.isPreview\n    });\n\n    if (effects.type === 'rewrite') {\n      parsed.pathname = effects.resolvedHref;\n      pathname = effects.resolvedHref;\n      query = { ...query,\n        ...effects.parsedAs.query\n      };\n      resolvedAs = effects.asPath;\n      url = (0, _utils).formatWithValidation(parsed);\n    }\n\n    const route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n    await Promise.all([this.pageLoader._isSsg(route).then(isSsg => {\n      return isSsg ? fetchNextData(this.pageLoader.getDataHref({\n        href: url,\n        asPath: resolvedAs,\n        ssg: true,\n        locale: typeof options.locale !== 'undefined' ? options.locale : this.locale\n      }), false, false, this.sdc, true) : false;\n    }), this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);\n  }\n\n  async fetchComponent(route) {\n    let cancelled = false;\n\n    const cancel = this.clc = () => {\n      cancelled = true;\n    };\n\n    const handleCancelled = () => {\n      if (cancelled) {\n        const error = new Error(`Abort fetching component for route: \"${route}\"`);\n        error.cancelled = true;\n        throw error;\n      }\n\n      if (cancel === this.clc) {\n        this.clc = null;\n      }\n    };\n\n    try {\n      const componentResult = await this.pageLoader.loadPage(route);\n      handleCancelled();\n      return componentResult;\n    } catch (err) {\n      handleCancelled();\n      throw err;\n    }\n  }\n\n  _getData(fn) {\n    let cancelled = false;\n\n    const cancel = () => {\n      cancelled = true;\n    };\n\n    this.clc = cancel;\n    return fn().then(data => {\n      if (cancel === this.clc) {\n        this.clc = null;\n      }\n\n      if (cancelled) {\n        const err = new Error('Loading initial props cancelled');\n        err.cancelled = true;\n        throw err;\n      }\n\n      return data;\n    });\n  }\n\n  _getFlightData(dataHref) {\n    // Do not cache RSC flight response since it's not a static resource\n    return fetchNextData(dataHref, true, true, this.sdc, false).then(serialized => {\n      return {\n        fresh: true,\n        data: serialized\n      };\n    });\n  }\n\n  async _preflightRequest(options) {\n    const cleanedAs = delLocale(hasBasePath(options.as) ? delBasePath(options.as) : options.as, options.locale);\n    const fns = await this.pageLoader.getMiddlewareList();\n    const requiresPreflight = fns.some(_ref2 => {\n      let [middleware, isSSR] = _ref2;\n      return (0, _routeMatcher).getRouteMatcher((0, _getMiddlewareRegex).getMiddlewareRegex(middleware, !isSSR))(cleanedAs);\n    });\n\n    if (!requiresPreflight) {\n      return {\n        type: 'next'\n      };\n    }\n\n    const preflight = await this._getPreflightData({\n      preflightHref: options.as,\n      shouldCache: options.cache,\n      isPreview: options.isPreview\n    });\n\n    if (preflight.rewrite) {\n      // for external rewrites we need to do a hard navigation\n      // to the resource\n      if (!preflight.rewrite.startsWith('/')) {\n        return {\n          type: 'redirect',\n          destination: options.as\n        };\n      }\n\n      const parsed = (0, _parseRelativeUrl).parseRelativeUrl((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(preflight.rewrite) ? delBasePath(preflight.rewrite) : preflight.rewrite, this.locales).pathname);\n      const fsPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash(parsed.pathname);\n      let matchedPage;\n      let resolvedHref;\n\n      if (options.pages.includes(fsPathname)) {\n        matchedPage = true;\n        resolvedHref = fsPathname;\n      } else {\n        resolvedHref = resolveDynamicRoute(fsPathname, options.pages);\n\n        if (resolvedHref !== parsed.pathname && options.pages.includes(resolvedHref)) {\n          matchedPage = true;\n        }\n      }\n\n      return {\n        type: 'rewrite',\n        asPath: parsed.pathname,\n        parsedAs: parsed,\n        matchedPage,\n        resolvedHref\n      };\n    }\n\n    if (preflight.redirect) {\n      if (preflight.redirect.startsWith('/')) {\n        const cleanRedirect = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(preflight.redirect) ? delBasePath(preflight.redirect) : preflight.redirect, this.locales).pathname);\n        const {\n          url: newUrl,\n          as: newAs\n        } = prepareUrlAs(this, cleanRedirect, cleanRedirect);\n        return {\n          type: 'redirect',\n          newUrl,\n          newAs\n        };\n      }\n\n      return {\n        type: 'redirect',\n        destination: preflight.redirect\n      };\n    } // For SSR requests, they will be handled like normal pages.\n\n\n    if (preflight.refresh && !preflight.ssr) {\n      return {\n        type: 'refresh'\n      };\n    }\n\n    return {\n      type: 'next'\n    };\n  }\n\n  _getPreflightData(params) {\n    const {\n      preflightHref,\n      shouldCache = false,\n      isPreview\n    } = params;\n    const {\n      href: cacheKey\n    } = new URL(preflightHref, window.location.href);\n\n    if (process.env.NODE_ENV === 'production' && !isPreview && shouldCache && this.sde[cacheKey]) {\n      return Promise.resolve(this.sde[cacheKey]);\n    }\n\n    return fetch(preflightHref, {\n      method: 'HEAD',\n      credentials: 'same-origin',\n      headers: {\n        'x-middleware-preflight': '1'\n      }\n    }).then(res => {\n      if (!res.ok) {\n        throw new Error(`Failed to preflight request`);\n      }\n\n      return {\n        cache: res.headers.get('x-middleware-cache'),\n        redirect: res.headers.get('Location'),\n        refresh: res.headers.has('x-middleware-refresh'),\n        rewrite: res.headers.get('x-middleware-rewrite'),\n        ssr: !!res.headers.get('x-middleware-ssr')\n      };\n    }).then(data => {\n      if (shouldCache && data.cache !== 'no-cache') {\n        this.sde[cacheKey] = data;\n      }\n\n      return data;\n    }).catch(err => {\n      delete this.sde[cacheKey];\n      throw err;\n    });\n  }\n\n  getInitialProps(Component, ctx) {\n    const {\n      Component: App\n    } = this.components['/_app'];\n\n    const AppTree = this._wrapApp(App);\n\n    ctx.AppTree = AppTree;\n    return (0, _utils).loadGetInitialProps(App, {\n      AppTree,\n      Component,\n      router: this,\n      ctx\n    });\n  }\n\n  abortComponentLoad(as, routeProps) {\n    if (this.clc) {\n      Router.events.emit('routeChangeError', buildCancellationError(), as, routeProps);\n      this.clc();\n      this.clc = null;\n    }\n  }\n\n  get route() {\n    return this.state.route;\n  }\n\n  get pathname() {\n    return this.state.pathname;\n  }\n\n  get query() {\n    return this.state.query;\n  }\n\n  get asPath() {\n    return this.state.asPath;\n  }\n\n  get locale() {\n    return this.state.locale;\n  }\n\n  get isFallback() {\n    return this.state.isFallback;\n  }\n\n  get isPreview() {\n    return this.state.isPreview;\n  }\n\n}\n\nRouter.events = (0, _mitt).default();\nexports.default = Router;","map":{"version":3,"sources":["C:/Users/schul/OneDrive/Desktop/PROIECTPORTOFOLIU/reactforum/node_modules/next/dist/shared/lib/router/router.js"],"names":["Object","defineProperty","exports","value","getDomainLocale","addLocale","delLocale","hasBasePath","addBasePath","delBasePath","isLocalURL","interpolateAs","resolveHref","default","_normalizeTrailingSlash","require","_routeLoader","_isError","_interopRequireWildcard","_denormalizePagePath","_normalizeLocalePath","_mitt","_interopRequireDefault","_utils","_isDynamic","_parseRelativeUrl","_querystring","_resolveRewrites","_routeMatcher","_routeRegex","_getMiddlewareRegex","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","desc","getOwnPropertyDescriptor","get","set","detectDomainLocale","process","env","__NEXT_I18N_SUPPORT","basePath","__NEXT_ROUTER_BASEPATH","buildCancellationError","assign","Error","cancelled","addPathPrefix","path","prefix","startsWith","pathname","pathNoQueryHash","normalizePathTrailingSlash","substr","length","locale","locales","domainLocales","normalizeLocalePath","detectedLocale","detectedDomain","undefined","http","domain","defaultLocale","pathLower","toLowerCase","localeLower","queryIndex","indexOf","hashIndex","substring","slice","url","locationOrigin","getLocationOrigin","resolved","URL","origin","_","route","asPathname","query","interpolatedRoute","dynamicRegex","getRouteRegex","dynamicGroups","groups","dynamicMatches","getRouteMatcher","params","keys","every","param","repeat","optional","replaced","Array","isArray","replace","map","segment","encodeURIComponent","join","result","omitParmsFromQuery","filteredQuery","forEach","includes","router","href","resolveAs","base","urlAsString","formatWithValidation","urlProtoMatch","match","urlAsStringNoProto","urlParts","split","console","error","normalizedUrl","normalizeRepeatedSlashes","asPath","finalUrl","interpolatedAs","isDynamicRoute","searchParams","searchParamsToUrlQuery","hash","resolvedHref","_1","stripOrigin","prepareUrlAs","as","resolvedAs","hrefHadOrigin","asHadOrigin","preparedUrl","preparedAs","resolveDynamicRoute","pages","cleanPathname","removePathTrailingSlash","denormalizePagePath","some","page","re","test","manualScrollRestoration","__NEXT_SCROLL_RESTORATION","window","history","v","sessionStorage","setItem","removeItem","n","SSG_DATA_NOT_FOUND","Symbol","fetchRetry","attempts","opts","fetch","credentials","then","res","ok","status","json","data","notFound","text","fetchNextData","dataHref","isServerRender","inflightCache","persistCache","cacheKey","location","catch","err","markAssetError","NODE_ENV","Router","constructor","initialProps","pageLoader","App","wrapApp","Component","subscription","isFallback","isPreview","sdc","sdr","sde","_idx","onPopState","e","state","changeState","getURL","__N","forcedScroll","options","idx","JSON","stringify","x","self","pageXOffset","y","pageYOffset","getItem","parse","parseRelativeUrl","isSsr","_bps","change","shallow","_shallow","components","ref","initial","props","__N_SSG","__N_SSP","__N_RSC","__next_rsc__","styleSheets","events","autoExportDynamic","__NEXT_DATA__","autoExport","sub","clc","_wrapApp","isLocaleDomain","isReady","gssp","gip","appGip","gsp","search","__NEXT_HAS_REWRITES","hostname","_shouldResolveHref","addEventListener","scrollRestoration","reload","back","push","method","shouldResolveHref","_h","nextState","prevLocale","parsedAs","localePathResult","didNavigate","asNoBasePath","Promise","ST","performance","mark","scroll","routeProps","_inFlightRoute","abortComponentLoad","cleanedAs","localeChange","onlyAHashChange","emit","scrollToHash","parsed","rewrites","__rewrites","all","getPageList","getClientBuildManifest","getMiddlewareList","urlIsNew","rewritesResult","p","externalDest","matchedPage","effect","_preflightRequest","cache","type","newAs","newUrl","destination","routeRegex","routeMatch","shouldInterpolate","missingParams","filter","warn","ref1","routeInfo","getRouteInfo","pageProps","__N_REDIRECT","__N_REDIRECT_BASE_PATH","parsedHref","__N_PREVIEW","notFoundRoute","fetchComponent","statusCode","isValidShallowRoute","_scroll","shouldScroll","resetScroll","document","documentElement","lang","err1","handleRouteInfoError","loadErrorFail","isAssetError","getInitialProps","gipErr","routeInfoErr","existingRouteInfo","cachedRouteInfo","mod","isValidElementType","getDataHref","ssg","rsc","_getData","fresh","_getFlightData","__flight_serialized__","__flight_fresh__","getProperError","beforePopState","cb","oldUrlNoHash","oldHash","newUrlNoHash","newHash","scrollTo","idEl","getElementById","scrollIntoView","nameEl","getElementsByName","prefetch","effects","_isSsg","isSsg","priority","cancel","handleCancelled","componentResult","loadPage","fn","serialized","fns","requiresPreflight","middleware","isSSR","getMiddlewareRegex","preflight","_getPreflightData","preflightHref","shouldCache","rewrite","fsPathname","redirect","cleanRedirect","refresh","ssr","resolve","headers","has","ctx","AppTree","loadGetInitialProps"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getDomainLocale = getDomainLocale;\nexports.addLocale = addLocale;\nexports.delLocale = delLocale;\nexports.hasBasePath = hasBasePath;\nexports.addBasePath = addBasePath;\nexports.delBasePath = delBasePath;\nexports.isLocalURL = isLocalURL;\nexports.interpolateAs = interpolateAs;\nexports.resolveHref = resolveHref;\nexports.default = void 0;\nvar _normalizeTrailingSlash = require(\"../../../client/normalize-trailing-slash\");\nvar _routeLoader = require(\"../../../client/route-loader\");\nvar _isError = _interopRequireWildcard(require(\"../../../lib/is-error\"));\nvar _denormalizePagePath = require(\"../../../server/denormalize-page-path\");\nvar _normalizeLocalePath = require(\"../i18n/normalize-locale-path\");\nvar _mitt = _interopRequireDefault(require(\"../mitt\"));\nvar _utils = require(\"../utils\");\nvar _isDynamic = require(\"./utils/is-dynamic\");\nvar _parseRelativeUrl = require(\"./utils/parse-relative-url\");\nvar _querystring = require(\"./utils/querystring\");\nvar _resolveRewrites = _interopRequireDefault(require(\"./utils/resolve-rewrites\"));\nvar _routeMatcher = require(\"./utils/route-matcher\");\nvar _routeRegex = require(\"./utils/route-regex\");\nvar _getMiddlewareRegex = require(\"./utils/get-middleware-regex\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n        return obj;\n    } else {\n        var newObj = {\n        };\n        if (obj != null) {\n            for(var key in obj){\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                    var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {\n                    };\n                    if (desc.get || desc.set) {\n                        Object.defineProperty(newObj, key, desc);\n                    } else {\n                        newObj[key] = obj[key];\n                    }\n                }\n            }\n        }\n        newObj.default = obj;\n        return newObj;\n    }\n}\nlet detectDomainLocale;\nif (process.env.__NEXT_I18N_SUPPORT) {\n    detectDomainLocale = require('../i18n/detect-domain-locale').detectDomainLocale;\n}\nconst basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\nfunction buildCancellationError() {\n    return Object.assign(new Error('Route Cancelled'), {\n        cancelled: true\n    });\n}\nfunction addPathPrefix(path, prefix) {\n    if (!path.startsWith('/') || !prefix) {\n        return path;\n    }\n    const pathname = pathNoQueryHash(path);\n    return (0, _normalizeTrailingSlash).normalizePathTrailingSlash(`${prefix}${pathname}`) + path.substr(pathname.length);\n}\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (process.env.__NEXT_I18N_SUPPORT) {\n        locale = locale || (0, _normalizeLocalePath).normalizeLocalePath(path, locales).detectedLocale;\n        const detectedDomain = detectDomainLocale(domainLocales, undefined, locale);\n        if (detectedDomain) {\n            return `http${detectedDomain.http ? '' : 's'}://${detectedDomain.domain}${basePath || ''}${locale === detectedDomain.defaultLocale ? '' : `/${locale}`}${path}`;\n        }\n        return false;\n    } else {\n        return false;\n    }\n}\nfunction addLocale(path, locale, defaultLocale) {\n    if (process.env.__NEXT_I18N_SUPPORT) {\n        const pathname = pathNoQueryHash(path);\n        const pathLower = pathname.toLowerCase();\n        const localeLower = locale && locale.toLowerCase();\n        return locale && locale !== defaultLocale && !pathLower.startsWith('/' + localeLower + '/') && pathLower !== '/' + localeLower ? addPathPrefix(path, '/' + locale) : path;\n    }\n    return path;\n}\nfunction delLocale(path, locale) {\n    if (process.env.__NEXT_I18N_SUPPORT) {\n        const pathname = pathNoQueryHash(path);\n        const pathLower = pathname.toLowerCase();\n        const localeLower = locale && locale.toLowerCase();\n        return locale && (pathLower.startsWith('/' + localeLower + '/') || pathLower === '/' + localeLower) ? (pathname.length === locale.length + 1 ? '/' : '') + path.substr(locale.length + 1) : path;\n    }\n    return path;\n}\nfunction pathNoQueryHash(path) {\n    const queryIndex = path.indexOf('?');\n    const hashIndex = path.indexOf('#');\n    if (queryIndex > -1 || hashIndex > -1) {\n        path = path.substring(0, queryIndex > -1 ? queryIndex : hashIndex);\n    }\n    return path;\n}\nfunction hasBasePath(path) {\n    path = pathNoQueryHash(path);\n    return path === basePath || path.startsWith(basePath + '/');\n}\nfunction addBasePath(path) {\n    // we only add the basepath on relative urls\n    return addPathPrefix(path, basePath);\n}\nfunction delBasePath(path) {\n    path = path.slice(basePath.length);\n    if (!path.startsWith('/')) path = `/${path}`;\n    return path;\n}\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (url.startsWith('/') || url.startsWith('#') || url.startsWith('?')) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        const locationOrigin = (0, _utils).getLocationOrigin();\n        const resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n}\nfunction interpolateAs(route, asPathname, query) {\n    let interpolatedRoute = '';\n    const dynamicRegex = (0, _routeRegex).getRouteRegex(route);\n    const dynamicGroups = dynamicRegex.groups;\n    const dynamicMatches = // Try to match the dynamic route against the asPath\n    (asPathname !== route ? (0, _routeMatcher).getRouteMatcher(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href\n    // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    const params = Object.keys(dynamicGroups);\n    if (!params.every((param)=>{\n        let value = dynamicMatches[param] || '';\n        const { repeat , optional  } = dynamicGroups[param];\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        let replaced = `[${repeat ? '...' : ''}${param}]`;\n        if (optional) {\n            replaced = `${!value ? '/' : ''}[${replaced}]`;\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present\n        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// these values should be fully encoded instead of just\n        // path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        (segment)=>encodeURIComponent(segment)\n        ).join('/') : encodeURIComponent(value)) || '/');\n    })) {\n        interpolatedRoute = '' // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params,\n        result: interpolatedRoute\n    };\n}\nfunction omitParmsFromQuery(query, params) {\n    const filteredQuery = {\n    };\n    Object.keys(query).forEach((key)=>{\n        if (!params.includes(key)) {\n            filteredQuery[key] = query[key];\n        }\n    });\n    return filteredQuery;\n}\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    let base;\n    let urlAsString = typeof href === 'string' ? href : (0, _utils).formatWithValidation(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    const urlAsStringNoProto = urlProtoMatch ? urlAsString.substr(urlProtoMatch[0].length) : urlAsString;\n    const urlParts = urlAsStringNoProto.split('?');\n    if ((urlParts[0] || '').match(/(\\/\\/|\\\\)/)) {\n        console.error(`Invalid href passed to next/router: ${urlAsString}, repeated forward-slashes (//) or backslashes \\\\ are not valid in the href`);\n        const normalizedUrl = (0, _utils).normalizeRepeatedSlashes(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!isLocalURL(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith('#') ? router.asPath : router.pathname, 'http://n');\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL('/', 'http://n');\n    }\n    try {\n        const finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizeTrailingSlash).normalizePathTrailingSlash(finalUrl.pathname);\n        let interpolatedAs = '';\n        if ((0, _isDynamic).isDynamicRoute(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            const query = (0, _querystring).searchParamsToUrlQuery(finalUrl.searchParams);\n            const { result , params  } = interpolateAs(finalUrl.pathname, finalUrl.pathname, query);\n            if (result) {\n                interpolatedAs = (0, _utils).formatWithValidation({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: omitParmsFromQuery(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_1) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\nfunction stripOrigin(url) {\n    const origin = (0, _utils).getLocationOrigin();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    let [resolvedHref, resolvedAs] = resolveHref(router, url, true);\n    const origin = (0, _utils).getLocationOrigin();\n    const hrefHadOrigin = resolvedHref.startsWith(origin);\n    const asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    const preparedUrl = hrefHadOrigin ? resolvedHref : addBasePath(resolvedHref);\n    const preparedAs = as ? stripOrigin(resolveHref(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asHadOrigin ? preparedAs : addBasePath(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    const cleanPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _denormalizePagePath).denormalizePagePath(pathname));\n    if (cleanPathname === '/404' || cleanPathname === '/_error') {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some((page)=>{\n            if ((0, _isDynamic).isDynamicRoute(page) && (0, _routeRegex).getRouteRegex(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n}\nconst manualScrollRestoration = process.env.__NEXT_SCROLL_RESTORATION && typeof window !== 'undefined' && 'scrollRestoration' in window.history && !!function() {\n    try {\n        let v = '__next';\n        // eslint-disable-next-line no-sequences\n        return sessionStorage.setItem(v, v), sessionStorage.removeItem(v), true;\n    } catch (n) {\n    }\n}();\nconst SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\nfunction fetchRetry(url, attempts, opts) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` wonâ€™t send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: 'same-origin'\n    }).then((res)=>{\n        if (!res.ok) {\n            if (attempts > 1 && res.status >= 500) {\n                return fetchRetry(url, attempts - 1, opts);\n            }\n            if (res.status === 404) {\n                return res.json().then((data)=>{\n                    if (data.notFound) {\n                        return {\n                            notFound: SSG_DATA_NOT_FOUND\n                        };\n                    }\n                    throw new Error(`Failed to load static props`);\n                });\n            }\n            throw new Error(`Failed to load static props`);\n        }\n        return opts.text ? res.text() : res.json();\n    });\n}\nfunction fetchNextData(dataHref, isServerRender, text, inflightCache, persistCache) {\n    const { href: cacheKey  } = new URL(dataHref, window.location.href);\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = fetchRetry(dataHref, isServerRender ? 3 : 1, {\n        text\n    }).catch((err)=>{\n        // We should only trigger a server-side transition if this was caused\n        // on a client-side transition. Otherwise, we'd get into an infinite\n        // loop.\n        if (!isServerRender) {\n            (0, _routeLoader).markAssetError(err);\n        }\n        throw err;\n    }).then((data)=>{\n        if (!persistCache || process.env.NODE_ENV !== 'production') {\n            delete inflightCache[cacheKey];\n        }\n        return data;\n    }).catch((err)=>{\n        delete inflightCache[cacheKey];\n        throw err;\n    });\n}\nclass Router {\n    constructor(pathname, query, as, { initialProps , pageLoader , App , wrapApp , Component , err , subscription , isFallback , locale , locales , defaultLocale , domainLocales , isPreview  }){\n        // Static Data Cache\n        this.sdc = {\n        };\n        // In-flight Server Data Requests, for deduping\n        this.sdr = {\n        };\n        // In-flight middleware preflight requests\n        this.sde = {\n        };\n        this._idx = 0;\n        this.onPopState = (e)=>{\n            const state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                const { pathname , query  } = this;\n                this.changeState('replaceState', (0, _utils).formatWithValidation({\n                    pathname: addBasePath(pathname),\n                    query\n                }), (0, _utils).getURL());\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            let forcedScroll;\n            const { url , as , options , idx  } = state;\n            if (process.env.__NEXT_SCROLL_RESTORATION) {\n                if (manualScrollRestoration) {\n                    if (this._idx !== idx) {\n                        // Snapshot current scroll position:\n                        try {\n                            sessionStorage.setItem('__next_scroll_' + this._idx, JSON.stringify({\n                                x: self.pageXOffset,\n                                y: self.pageYOffset\n                            }));\n                        } catch  {\n                        }\n                        // Restore old scroll position:\n                        try {\n                            const v = sessionStorage.getItem('__next_scroll_' + idx);\n                            forcedScroll = JSON.parse(v);\n                        } catch  {\n                            forcedScroll = {\n                                x: 0,\n                                y: 0\n                            };\n                        }\n                    }\n                }\n            }\n            this._idx = idx;\n            const { pathname  } = (0, _parseRelativeUrl).parseRelativeUrl(url);\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (this.isSsr && as === addBasePath(this.asPath) && pathname === addBasePath(this.pathname)) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (this._bps && !this._bps(state)) {\n                return;\n            }\n            this.change('replaceState', url, as, Object.assign({\n            }, options, {\n                shallow: options.shallow && this._shallow,\n                locale: options.locale || this.defaultLocale\n            }), forcedScroll);\n        };\n        // represents the current component key\n        const route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n        // set up the component cache (by route keys)\n        this.components = {\n        };\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname !== '/_error') {\n            var ref;\n            this.components[route] = {\n                Component,\n                initial: true,\n                props: initialProps,\n                err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP,\n                __N_RSC: !!((ref = Component) === null || ref === void 0 ? void 0 : ref.__next_rsc__)\n            };\n        }\n        this.components['/_app'] = {\n            Component: App,\n            styleSheets: []\n        };\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        const autoExportDynamic = (0, _isDynamic).isDynamicRoute(pathname) && self.__NEXT_DATA__.autoExport;\n        this.basePath = basePath;\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isLocaleDomain = false;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !process.env.__NEXT_HAS_REWRITES);\n        if (process.env.__NEXT_I18N_SUPPORT) {\n            this.locales = locales;\n            this.defaultLocale = defaultLocale;\n            this.domainLocales = domainLocales;\n            this.isLocaleDomain = !!detectDomainLocale(domainLocales, self.location.hostname);\n        }\n        this.state = {\n            route,\n            pathname,\n            query,\n            asPath: autoExportDynamic ? pathname : as,\n            isPreview: !!isPreview,\n            locale: process.env.__NEXT_I18N_SUPPORT ? locale : undefined,\n            isFallback\n        };\n        if (typeof window !== 'undefined') {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (as.substr(0, 2) !== '//') {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                const options = {\n                    locale\n                };\n                options._shouldResolveHref = as !== pathname;\n                this.changeState('replaceState', (0, _utils).formatWithValidation({\n                    pathname: addBasePath(pathname),\n                    query\n                }), (0, _utils).getURL(), options);\n            }\n            window.addEventListener('popstate', this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (process.env.__NEXT_SCROLL_RESTORATION) {\n                if (manualScrollRestoration) {\n                    window.history.scrollRestoration = 'manual';\n                }\n            }\n        }\n    }\n    reload() {\n        window.location.reload();\n    }\n    /**\n   * Go back in history\n   */ back() {\n        window.history.back();\n    }\n    /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ push(url, as, options = {\n    }) {\n        if (process.env.__NEXT_SCROLL_RESTORATION) {\n            // TODO: remove in the future when we update history before route change\n            // is complete, as the popstate event should handle this capture.\n            if (manualScrollRestoration) {\n                try {\n                    // Snapshot scroll position right before navigating to a new page:\n                    sessionStorage.setItem('__next_scroll_' + this._idx, JSON.stringify({\n                        x: self.pageXOffset,\n                        y: self.pageYOffset\n                    }));\n                } catch  {\n                }\n            }\n        }\n        ({ url , as  } = prepareUrlAs(this, url, as));\n        return this.change('pushState', url, as, options);\n    }\n    /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ replace(url, as, options = {\n    }) {\n        ({ url , as  } = prepareUrlAs(this, url, as));\n        return this.change('replaceState', url, as, options);\n    }\n    async change(method, url, as, options, forcedScroll) {\n        if (!isLocalURL(url)) {\n            window.location.href = url;\n            return false;\n        }\n        const shouldResolveHref = options._h || options._shouldResolveHref || pathNoQueryHash(url) === pathNoQueryHash(as);\n        const nextState = {\n            ...this.state\n        };\n        // for static pages with query params in the URL we delay\n        // marking the router ready until after the query is updated\n        if (options._h) {\n            this.isReady = true;\n        }\n        const prevLocale = nextState.locale;\n        if (process.env.__NEXT_I18N_SUPPORT) {\n            nextState.locale = options.locale === false ? this.defaultLocale : options.locale || nextState.locale;\n            if (typeof options.locale === 'undefined') {\n                options.locale = nextState.locale;\n            }\n            const parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(hasBasePath(as) ? delBasePath(as) : as);\n            const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, this.locales);\n            if (localePathResult.detectedLocale) {\n                nextState.locale = localePathResult.detectedLocale;\n                parsedAs.pathname = addBasePath(parsedAs.pathname);\n                as = (0, _utils).formatWithValidation(parsedAs);\n                url = addBasePath((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(url) ? delBasePath(url) : url, this.locales).pathname);\n            }\n            let didNavigate = false;\n            // we need to wrap this in the env check again since regenerator runtime\n            // moves this on its own due to the return\n            if (process.env.__NEXT_I18N_SUPPORT) {\n                var ref;\n                // if the locale isn't configured hard navigate to show 404 page\n                if (!((ref = this.locales) === null || ref === void 0 ? void 0 : ref.includes(nextState.locale))) {\n                    parsedAs.pathname = addLocale(parsedAs.pathname, nextState.locale);\n                    window.location.href = (0, _utils).formatWithValidation(parsedAs);\n                    // this was previously a return but was removed in favor\n                    // of better dead code elimination with regenerator runtime\n                    didNavigate = true;\n                }\n            }\n            const detectedDomain = detectDomainLocale(this.domainLocales, undefined, nextState.locale);\n            // we need to wrap this in the env check again since regenerator runtime\n            // moves this on its own due to the return\n            if (process.env.__NEXT_I18N_SUPPORT) {\n                // if we are navigating to a domain locale ensure we redirect to the\n                // correct domain\n                if (!didNavigate && detectedDomain && this.isLocaleDomain && self.location.hostname !== detectedDomain.domain) {\n                    const asNoBasePath = delBasePath(as);\n                    window.location.href = `http${detectedDomain.http ? '' : 's'}://${detectedDomain.domain}${addBasePath(`${nextState.locale === detectedDomain.defaultLocale ? '' : `/${nextState.locale}`}${asNoBasePath === '/' ? '' : asNoBasePath}` || '/')}`;\n                    // this was previously a return but was removed in favor\n                    // of better dead code elimination with regenerator runtime\n                    didNavigate = true;\n                }\n            }\n            if (didNavigate) {\n                return new Promise(()=>{\n                });\n            }\n        }\n        if (!options._h) {\n            this.isSsr = false;\n        }\n        // marking route changes as a navigation start entry\n        if (_utils.ST) {\n            performance.mark('routeChange');\n        }\n        const { shallow =false , scroll =true  } = options;\n        const routeProps = {\n            shallow\n        };\n        if (this._inFlightRoute) {\n            this.abortComponentLoad(this._inFlightRoute, routeProps);\n        }\n        as = addBasePath(addLocale(hasBasePath(as) ? delBasePath(as) : as, options.locale, this.defaultLocale));\n        const cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, nextState.locale);\n        this._inFlightRoute = as;\n        let localeChange = prevLocale !== nextState.locale;\n        // If the url change is only related to a hash change\n        // We should not proceed. We should only change the state.\n        // WARNING: `_h` is an internal option for handing Next.js client-side\n        // hydration. Your app should _never_ use this property. It may change at\n        // any time without notice.\n        if (!options._h && this.onlyAHashChange(cleanedAs) && !localeChange) {\n            nextState.asPath = cleanedAs;\n            Router.events.emit('hashChangeStart', as, routeProps);\n            // TODO: do we need the resolved href when only a hash change?\n            this.changeState(method, url, as, {\n                ...options,\n                scroll: false\n            });\n            if (scroll) {\n                this.scrollToHash(cleanedAs);\n            }\n            this.set(nextState, this.components[nextState.route], null);\n            Router.events.emit('hashChangeComplete', as, routeProps);\n            return true;\n        }\n        let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n        let { pathname , query  } = parsed;\n        // The build manifest needs to be loaded before auto-static dynamic pages\n        // get their query parameters to allow ensuring they can be parsed properly\n        // when rewritten to\n        let pages, rewrites;\n        try {\n            [pages, { __rewrites: rewrites  }] = await Promise.all([\n                this.pageLoader.getPageList(),\n                (0, _routeLoader).getClientBuildManifest(),\n                this.pageLoader.getMiddlewareList(), \n            ]);\n        } catch (err) {\n            // If we fail to resolve the page list or client-build manifest, we must\n            // do a server-side transition:\n            window.location.href = as;\n            return false;\n        }\n        // If asked to change the current URL we should reload the current page\n        // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n        // We also need to set the method = replaceState always\n        // as this should not go into the history (That's how browsers work)\n        // We should compare the new asPath to the current asPath, not the url\n        if (!this.urlIsNew(cleanedAs) && !localeChange) {\n            method = 'replaceState';\n        }\n        // we need to resolve the as value using rewrites for dynamic SSG\n        // pages to allow building the data URL correctly\n        let resolvedAs = as;\n        // url and as should always be prefixed with basePath by this\n        // point by either next/link or router.push/replace so strip the\n        // basePath from the pathname to match the pages dir 1-to-1\n        pathname = pathname ? (0, _normalizeTrailingSlash).removePathTrailingSlash(delBasePath(pathname)) : pathname;\n        if (shouldResolveHref && pathname !== '/_error') {\n            options._shouldResolveHref = true;\n            if (process.env.__NEXT_HAS_REWRITES && as.startsWith('/')) {\n                const rewritesResult = (0, _resolveRewrites).default(addBasePath(addLocale(cleanedAs, nextState.locale)), pages, rewrites, query, (p)=>resolveDynamicRoute(p, pages)\n                , this.locales);\n                if (rewritesResult.externalDest) {\n                    location.href = as;\n                    return true;\n                }\n                resolvedAs = rewritesResult.asPath;\n                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                    // if this directly matches a page we need to update the href to\n                    // allow the correct page chunk to be loaded\n                    pathname = rewritesResult.resolvedHref;\n                    parsed.pathname = addBasePath(pathname);\n                    url = (0, _utils).formatWithValidation(parsed);\n                }\n            } else {\n                parsed.pathname = resolveDynamicRoute(pathname, pages);\n                if (parsed.pathname !== pathname) {\n                    pathname = parsed.pathname;\n                    parsed.pathname = addBasePath(pathname);\n                    url = (0, _utils).formatWithValidation(parsed);\n                }\n            }\n        }\n        if (!isLocalURL(as)) {\n            if (process.env.NODE_ENV !== 'production') {\n                throw new Error(`Invalid href: \"${url}\" and as: \"${as}\", received relative href and external as` + `\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as`);\n            }\n            window.location.href = as;\n            return false;\n        }\n        resolvedAs = delLocale(delBasePath(resolvedAs), nextState.locale);\n        /**\n     * If the route update was triggered for client-side hydration and\n     * the rendered route is not dynamic do not check the preflight\n     * request as it is not necessary.\n     */ if (options._h !== 1 || (0, _isDynamic).isDynamicRoute((0, _normalizeTrailingSlash).removePathTrailingSlash(pathname))) {\n            const effect = await this._preflightRequest({\n                as,\n                cache: process.env.NODE_ENV === 'production',\n                pages,\n                pathname,\n                query,\n                locale: nextState.locale,\n                isPreview: nextState.isPreview\n            });\n            if (effect.type === 'rewrite') {\n                query = {\n                    ...query,\n                    ...effect.parsedAs.query\n                };\n                resolvedAs = effect.asPath;\n                pathname = effect.resolvedHref;\n                parsed.pathname = effect.resolvedHref;\n                url = (0, _utils).formatWithValidation(parsed);\n            } else if (effect.type === 'redirect' && effect.newAs) {\n                return this.change(method, effect.newUrl, effect.newAs, options);\n            } else if (effect.type === 'redirect' && effect.destination) {\n                window.location.href = effect.destination;\n                return new Promise(()=>{\n                });\n            } else if (effect.type === 'refresh' && as !== window.location.pathname) {\n                window.location.href = as;\n                return new Promise(()=>{\n                });\n            }\n        }\n        const route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n        if ((0, _isDynamic).isDynamicRoute(route)) {\n            const parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs);\n            const asPathname = parsedAs.pathname;\n            const routeRegex = (0, _routeRegex).getRouteRegex(route);\n            const routeMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(asPathname);\n            const shouldInterpolate = route === asPathname;\n            const interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {\n            };\n            if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n                const missingParams = Object.keys(routeRegex.groups).filter((param)=>!query[param]\n                );\n                if (missingParams.length > 0) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        console.warn(`${shouldInterpolate ? `Interpolating href` : `Mismatching \\`as\\` and \\`href\\``} failed to manually provide ` + `the params: ${missingParams.join(', ')} in the \\`href\\`'s \\`query\\``);\n                    }\n                    throw new Error((shouldInterpolate ? `The provided \\`href\\` (${url}) value is missing query values (${missingParams.join(', ')}) to be interpolated properly. ` : `The provided \\`as\\` value (${asPathname}) is incompatible with the \\`href\\` value (${route}). `) + `Read more: https://nextjs.org/docs/messages/${shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'}`);\n                }\n            } else if (shouldInterpolate) {\n                as = (0, _utils).formatWithValidation(Object.assign({\n                }, parsedAs, {\n                    pathname: interpolatedAs.result,\n                    query: omitParmsFromQuery(query, interpolatedAs.params)\n                }));\n            } else {\n                // Merge params into `query`, overwriting any specified in search\n                Object.assign(query, routeMatch);\n            }\n        }\n        Router.events.emit('routeChangeStart', as, routeProps);\n        try {\n            var ref, ref1;\n            let routeInfo = await this.getRouteInfo(route, pathname, query, as, resolvedAs, routeProps, nextState.locale, nextState.isPreview);\n            let { error , props , __N_SSG , __N_SSP  } = routeInfo;\n            // handle redirect on client-transition\n            if ((__N_SSG || __N_SSP) && props) {\n                if (props.pageProps && props.pageProps.__N_REDIRECT) {\n                    const destination = props.pageProps.__N_REDIRECT;\n                    // check if destination is internal (resolves to a page) and attempt\n                    // client-navigation if it is falling back to hard navigation if\n                    // it's not\n                    if (destination.startsWith('/') && props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n                        const parsedHref = (0, _parseRelativeUrl).parseRelativeUrl(destination);\n                        parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                        const { url: newUrl , as: newAs  } = prepareUrlAs(this, destination, destination);\n                        return this.change(method, newUrl, newAs, options);\n                    }\n                    window.location.href = destination;\n                    return new Promise(()=>{\n                    });\n                }\n                nextState.isPreview = !!props.__N_PREVIEW;\n                // handle SSG data 404\n                if (props.notFound === SSG_DATA_NOT_FOUND) {\n                    let notFoundRoute;\n                    try {\n                        await this.fetchComponent('/404');\n                        notFoundRoute = '/404';\n                    } catch (_) {\n                        notFoundRoute = '/_error';\n                    }\n                    routeInfo = await this.getRouteInfo(notFoundRoute, notFoundRoute, query, as, resolvedAs, {\n                        shallow: false\n                    }, nextState.locale, nextState.isPreview);\n                }\n            }\n            Router.events.emit('beforeHistoryChange', as, routeProps);\n            this.changeState(method, url, as, options);\n            if (options._h && pathname === '/_error' && ((ref = self.__NEXT_DATA__.props) === null || ref === void 0 ? void 0 : (ref1 = ref.pageProps) === null || ref1 === void 0 ? void 0 : ref1.statusCode) === 500 && (props === null || props === void 0 ? void 0 : props.pageProps)) {\n                // ensure statusCode is still correct for static 500 page\n                // when updating query information\n                props.pageProps.statusCode = 500;\n            }\n            // shallow routing is only allowed for same page URL changes.\n            const isValidShallowRoute = options.shallow && nextState.route === route;\n            var _scroll;\n            const shouldScroll = (_scroll = options.scroll) !== null && _scroll !== void 0 ? _scroll : !isValidShallowRoute;\n            const resetScroll = shouldScroll ? {\n                x: 0,\n                y: 0\n            } : null;\n            await this.set({\n                ...nextState,\n                route,\n                pathname,\n                query,\n                asPath: cleanedAs,\n                isFallback: false\n            }, routeInfo, forcedScroll !== null && forcedScroll !== void 0 ? forcedScroll : resetScroll).catch((e)=>{\n                if (e.cancelled) error = error || e;\n                else throw e;\n            });\n            if (error) {\n                Router.events.emit('routeChangeError', error, cleanedAs, routeProps);\n                throw error;\n            }\n            if (process.env.__NEXT_I18N_SUPPORT) {\n                if (nextState.locale) {\n                    document.documentElement.lang = nextState.locale;\n                }\n            }\n            Router.events.emit('routeChangeComplete', as, routeProps);\n            return true;\n        } catch (err1) {\n            if ((0, _isError).default(err1) && err1.cancelled) {\n                return false;\n            }\n            throw err1;\n        }\n    }\n    changeState(method, url, as, options = {\n    }) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (typeof window.history === 'undefined') {\n                console.error(`Warning: window.history is not available.`);\n                return;\n            }\n            if (typeof window.history[method] === 'undefined') {\n                console.error(`Warning: window.history.${method} is not available`);\n                return;\n            }\n        }\n        if (method !== 'pushState' || (0, _utils).getURL() !== as) {\n            this._shallow = options.shallow;\n            window.history[method]({\n                url,\n                as,\n                options,\n                __N: true,\n                idx: this._idx = method !== 'pushState' ? this._idx : this._idx + 1\n            }, // Most browsers currently ignores this parameter, although they may use it in the future.\n            // Passing the empty string here should be safe against future changes to the method.\n            // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n            '', as);\n        }\n    }\n    async handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n        if (err.cancelled) {\n            // bubble up cancellation errors\n            throw err;\n        }\n        if ((0, _routeLoader).isAssetError(err) || loadErrorFail) {\n            Router.events.emit('routeChangeError', err, as, routeProps);\n            // If we can't load the page it could be one of following reasons\n            //  1. Page doesn't exists\n            //  2. Page does exist in a different zone\n            //  3. Internal error while loading the page\n            // So, doing a hard reload is the proper way to deal with this.\n            window.location.href = as;\n            // Changing the URL doesn't block executing the current code path.\n            // So let's throw a cancellation error stop the routing logic.\n            throw buildCancellationError();\n        }\n        try {\n            let Component;\n            let styleSheets;\n            let props;\n            if (typeof Component === 'undefined' || typeof styleSheets === 'undefined') {\n                ({ page: Component , styleSheets  } = await this.fetchComponent('/_error'));\n            }\n            const routeInfo = {\n                props,\n                Component,\n                styleSheets,\n                err,\n                error: err\n            };\n            if (!routeInfo.props) {\n                try {\n                    routeInfo.props = await this.getInitialProps(Component, {\n                        err,\n                        pathname,\n                        query\n                    });\n                } catch (gipErr) {\n                    console.error('Error in error page `getInitialProps`: ', gipErr);\n                    routeInfo.props = {\n                    };\n                }\n            }\n            return routeInfo;\n        } catch (routeInfoErr) {\n            return this.handleRouteInfoError((0, _isError).default(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + ''), pathname, query, as, routeProps, true);\n        }\n    }\n    async getRouteInfo(route, pathname, query, as, resolvedAs, routeProps, locale, isPreview) {\n        try {\n            const existingRouteInfo = this.components[route];\n            if (routeProps.shallow && existingRouteInfo && this.route === route) {\n                return existingRouteInfo;\n            }\n            let cachedRouteInfo = undefined;\n            // can only use non-initial route info\n            // cannot reuse route info in development since it can change after HMR\n            if (process.env.NODE_ENV !== 'development' && existingRouteInfo && !('initial' in existingRouteInfo)) {\n                cachedRouteInfo = existingRouteInfo;\n            }\n            const routeInfo = cachedRouteInfo || await this.fetchComponent(route).then((res)=>({\n                    Component: res.page,\n                    styleSheets: res.styleSheets,\n                    __N_SSG: res.mod.__N_SSG,\n                    __N_SSP: res.mod.__N_SSP,\n                    __N_RSC: !!res.page.__next_rsc__\n                })\n            );\n            const { Component , __N_SSG , __N_SSP , __N_RSC  } = routeInfo;\n            if (process.env.NODE_ENV !== 'production') {\n                const { isValidElementType  } = require('next/dist/compiled/react-is');\n                if (!isValidElementType(Component)) {\n                    throw new Error(`The default export is not a React Component in page: \"${pathname}\"`);\n                }\n            }\n            let dataHref;\n            if (__N_SSG || __N_SSP || __N_RSC) {\n                dataHref = this.pageLoader.getDataHref({\n                    href: (0, _utils).formatWithValidation({\n                        pathname,\n                        query\n                    }),\n                    asPath: resolvedAs,\n                    ssg: __N_SSG,\n                    rsc: __N_RSC,\n                    locale\n                });\n            }\n            const props = await this._getData(()=>__N_SSG || __N_SSP ? fetchNextData(dataHref, this.isSsr, false, __N_SSG ? this.sdc : this.sdr, !!__N_SSG && !isPreview) : this.getInitialProps(Component, // we provide AppTree later so this needs to be `any`\n                {\n                    pathname,\n                    query,\n                    asPath: as,\n                    locale,\n                    locales: this.locales,\n                    defaultLocale: this.defaultLocale\n                })\n            );\n            if (__N_RSC) {\n                const { fresh , data  } = await this._getData(()=>this._getFlightData(dataHref)\n                );\n                props.pageProps = Object.assign(props.pageProps, {\n                    __flight_serialized__: data,\n                    __flight_fresh__: fresh\n                });\n            }\n            routeInfo.props = props;\n            this.components[route] = routeInfo;\n            return routeInfo;\n        } catch (err) {\n            return this.handleRouteInfoError((0, _isError).getProperError(err), pathname, query, as, routeProps);\n        }\n    }\n    set(state, data, resetScroll) {\n        this.state = state;\n        return this.sub(data, this.components['/_app'].Component, resetScroll);\n    }\n    /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */ beforePopState(cb) {\n        this._bps = cb;\n    }\n    onlyAHashChange(as) {\n        if (!this.asPath) return false;\n        const [oldUrlNoHash, oldHash] = this.asPath.split('#');\n        const [newUrlNoHash, newHash] = as.split('#');\n        // Makes sure we scroll to the provided hash if the url/hash are the same\n        if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n            return true;\n        }\n        // If the urls are change, there's more than a hash change\n        if (oldUrlNoHash !== newUrlNoHash) {\n            return false;\n        }\n        // If the hash has changed, then it's a hash only change.\n        // This check is necessary to handle both the enter and\n        // leave hash === '' cases. The identity case falls through\n        // and is treated as a next reload.\n        return oldHash !== newHash;\n    }\n    scrollToHash(as) {\n        const [, hash = ''] = as.split('#');\n        // Scroll to top if the hash is just `#` with no value or `#top`\n        // To mirror browsers\n        if (hash === '' || hash === 'top') {\n            window.scrollTo(0, 0);\n            return;\n        }\n        // First we check if the element by id is found\n        const idEl = document.getElementById(hash);\n        if (idEl) {\n            idEl.scrollIntoView();\n            return;\n        }\n        // If there's no element with the id, we check the `name` property\n        // To mirror browsers\n        const nameEl = document.getElementsByName(hash)[0];\n        if (nameEl) {\n            nameEl.scrollIntoView();\n        }\n    }\n    urlIsNew(asPath) {\n        return this.asPath !== asPath;\n    }\n    /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */ async prefetch(url, asPath = url, options = {\n    }) {\n        let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n        let { pathname , query  } = parsed;\n        if (process.env.__NEXT_I18N_SUPPORT) {\n            if (options.locale === false) {\n                pathname = (0, _normalizeLocalePath).normalizeLocalePath(pathname, this.locales).pathname;\n                parsed.pathname = pathname;\n                url = (0, _utils).formatWithValidation(parsed);\n                let parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(asPath);\n                const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, this.locales);\n                parsedAs.pathname = localePathResult.pathname;\n                options.locale = localePathResult.detectedLocale || this.defaultLocale;\n                asPath = (0, _utils).formatWithValidation(parsedAs);\n            }\n        }\n        const pages = await this.pageLoader.getPageList();\n        let resolvedAs = asPath;\n        if (process.env.__NEXT_HAS_REWRITES && asPath.startsWith('/')) {\n            let rewrites;\n            ({ __rewrites: rewrites  } = await (0, _routeLoader).getClientBuildManifest());\n            const rewritesResult = (0, _resolveRewrites).default(addBasePath(addLocale(asPath, this.locale)), pages, rewrites, parsed.query, (p)=>resolveDynamicRoute(p, pages)\n            , this.locales);\n            if (rewritesResult.externalDest) {\n                return;\n            }\n            resolvedAs = delLocale(delBasePath(rewritesResult.asPath), this.locale);\n            if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                // if this directly matches a page we need to update the href to\n                // allow the correct page chunk to be loaded\n                pathname = rewritesResult.resolvedHref;\n                parsed.pathname = pathname;\n                url = (0, _utils).formatWithValidation(parsed);\n            }\n        } else {\n            parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n            if (parsed.pathname !== pathname) {\n                pathname = parsed.pathname;\n                parsed.pathname = pathname;\n                url = (0, _utils).formatWithValidation(parsed);\n            }\n        }\n        // Prefetch is not supported in development mode because it would trigger on-demand-entries\n        if (process.env.NODE_ENV !== 'production') {\n            return;\n        }\n        const effects = await this._preflightRequest({\n            as: addBasePath(asPath),\n            cache: true,\n            pages,\n            pathname,\n            query,\n            locale: this.locale,\n            isPreview: this.isPreview\n        });\n        if (effects.type === 'rewrite') {\n            parsed.pathname = effects.resolvedHref;\n            pathname = effects.resolvedHref;\n            query = {\n                ...query,\n                ...effects.parsedAs.query\n            };\n            resolvedAs = effects.asPath;\n            url = (0, _utils).formatWithValidation(parsed);\n        }\n        const route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n        await Promise.all([\n            this.pageLoader._isSsg(route).then((isSsg)=>{\n                return isSsg ? fetchNextData(this.pageLoader.getDataHref({\n                    href: url,\n                    asPath: resolvedAs,\n                    ssg: true,\n                    locale: typeof options.locale !== 'undefined' ? options.locale : this.locale\n                }), false, false, this.sdc, true) : false;\n            }),\n            this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route), \n        ]);\n    }\n    async fetchComponent(route) {\n        let cancelled = false;\n        const cancel = this.clc = ()=>{\n            cancelled = true;\n        };\n        const handleCancelled = ()=>{\n            if (cancelled) {\n                const error = new Error(`Abort fetching component for route: \"${route}\"`);\n                error.cancelled = true;\n                throw error;\n            }\n            if (cancel === this.clc) {\n                this.clc = null;\n            }\n        };\n        try {\n            const componentResult = await this.pageLoader.loadPage(route);\n            handleCancelled();\n            return componentResult;\n        } catch (err) {\n            handleCancelled();\n            throw err;\n        }\n    }\n    _getData(fn) {\n        let cancelled = false;\n        const cancel = ()=>{\n            cancelled = true;\n        };\n        this.clc = cancel;\n        return fn().then((data)=>{\n            if (cancel === this.clc) {\n                this.clc = null;\n            }\n            if (cancelled) {\n                const err = new Error('Loading initial props cancelled');\n                err.cancelled = true;\n                throw err;\n            }\n            return data;\n        });\n    }\n    _getFlightData(dataHref) {\n        // Do not cache RSC flight response since it's not a static resource\n        return fetchNextData(dataHref, true, true, this.sdc, false).then((serialized)=>{\n            return {\n                fresh: true,\n                data: serialized\n            };\n        });\n    }\n    async _preflightRequest(options) {\n        const cleanedAs = delLocale(hasBasePath(options.as) ? delBasePath(options.as) : options.as, options.locale);\n        const fns = await this.pageLoader.getMiddlewareList();\n        const requiresPreflight = fns.some(([middleware, isSSR])=>{\n            return (0, _routeMatcher).getRouteMatcher((0, _getMiddlewareRegex).getMiddlewareRegex(middleware, !isSSR))(cleanedAs);\n        });\n        if (!requiresPreflight) {\n            return {\n                type: 'next'\n            };\n        }\n        const preflight = await this._getPreflightData({\n            preflightHref: options.as,\n            shouldCache: options.cache,\n            isPreview: options.isPreview\n        });\n        if (preflight.rewrite) {\n            // for external rewrites we need to do a hard navigation\n            // to the resource\n            if (!preflight.rewrite.startsWith('/')) {\n                return {\n                    type: 'redirect',\n                    destination: options.as\n                };\n            }\n            const parsed = (0, _parseRelativeUrl).parseRelativeUrl((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(preflight.rewrite) ? delBasePath(preflight.rewrite) : preflight.rewrite, this.locales).pathname);\n            const fsPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash(parsed.pathname);\n            let matchedPage;\n            let resolvedHref;\n            if (options.pages.includes(fsPathname)) {\n                matchedPage = true;\n                resolvedHref = fsPathname;\n            } else {\n                resolvedHref = resolveDynamicRoute(fsPathname, options.pages);\n                if (resolvedHref !== parsed.pathname && options.pages.includes(resolvedHref)) {\n                    matchedPage = true;\n                }\n            }\n            return {\n                type: 'rewrite',\n                asPath: parsed.pathname,\n                parsedAs: parsed,\n                matchedPage,\n                resolvedHref\n            };\n        }\n        if (preflight.redirect) {\n            if (preflight.redirect.startsWith('/')) {\n                const cleanRedirect = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(preflight.redirect) ? delBasePath(preflight.redirect) : preflight.redirect, this.locales).pathname);\n                const { url: newUrl , as: newAs  } = prepareUrlAs(this, cleanRedirect, cleanRedirect);\n                return {\n                    type: 'redirect',\n                    newUrl,\n                    newAs\n                };\n            }\n            return {\n                type: 'redirect',\n                destination: preflight.redirect\n            };\n        }\n        // For SSR requests, they will be handled like normal pages.\n        if (preflight.refresh && !preflight.ssr) {\n            return {\n                type: 'refresh'\n            };\n        }\n        return {\n            type: 'next'\n        };\n    }\n    _getPreflightData(params) {\n        const { preflightHref , shouldCache =false , isPreview  } = params;\n        const { href: cacheKey  } = new URL(preflightHref, window.location.href);\n        if (process.env.NODE_ENV === 'production' && !isPreview && shouldCache && this.sde[cacheKey]) {\n            return Promise.resolve(this.sde[cacheKey]);\n        }\n        return fetch(preflightHref, {\n            method: 'HEAD',\n            credentials: 'same-origin',\n            headers: {\n                'x-middleware-preflight': '1'\n            }\n        }).then((res)=>{\n            if (!res.ok) {\n                throw new Error(`Failed to preflight request`);\n            }\n            return {\n                cache: res.headers.get('x-middleware-cache'),\n                redirect: res.headers.get('Location'),\n                refresh: res.headers.has('x-middleware-refresh'),\n                rewrite: res.headers.get('x-middleware-rewrite'),\n                ssr: !!res.headers.get('x-middleware-ssr')\n            };\n        }).then((data)=>{\n            if (shouldCache && data.cache !== 'no-cache') {\n                this.sde[cacheKey] = data;\n            }\n            return data;\n        }).catch((err)=>{\n            delete this.sde[cacheKey];\n            throw err;\n        });\n    }\n    getInitialProps(Component, ctx) {\n        const { Component: App  } = this.components['/_app'];\n        const AppTree = this._wrapApp(App);\n        ctx.AppTree = AppTree;\n        return (0, _utils).loadGetInitialProps(App, {\n            AppTree,\n            Component,\n            router: this,\n            ctx\n        });\n    }\n    abortComponentLoad(as, routeProps) {\n        if (this.clc) {\n            Router.events.emit('routeChangeError', buildCancellationError(), as, routeProps);\n            this.clc();\n            this.clc = null;\n        }\n    }\n    get route() {\n        return this.state.route;\n    }\n    get pathname() {\n        return this.state.pathname;\n    }\n    get query() {\n        return this.state.query;\n    }\n    get asPath() {\n        return this.state.asPath;\n    }\n    get locale() {\n        return this.state.locale;\n    }\n    get isFallback() {\n        return this.state.isFallback;\n    }\n    get isPreview() {\n        return this.state.isPreview;\n    }\n}\nRouter.events = (0, _mitt).default();\nexports.default = Router;\n\n//# sourceMappingURL=router.js.map"]},"metadata":{},"sourceType":"script"}